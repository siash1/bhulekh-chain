#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "anchor_authority" "total_anchors" 0x "last_anchor_round" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // contracts/title_proof.py:40
    // self.anchor_authority = GlobalState(Bytes(b""))
    bytec_0 // "anchor_authority"
    bytec_2 // 0x
    app_global_put
    // contracts/title_proof.py:41
    // self.total_anchors = GlobalState(UInt64(0))
    bytec_1 // "total_anchors"
    intc_0 // 0
    app_global_put
    // contracts/title_proof.py:42
    // self.last_anchor_round = GlobalState(UInt64(0))
    bytec_3 // "last_anchor_round"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // contracts/title_proof.py:22
    // class TitleProofAnchor(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0xee1c7156 0xddafafb2 0xb275b539 0x0f387a14 // method "initialize(address)void", method "anchor_state(string,string,uint64,uint64,byte[],uint64)uint64", method "get_anchor_count()uint64", method "rotate_authority(address)void"
    txna ApplicationArgs 0
    match initialize anchor_state get_anchor_count rotate_authority
    err

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// contracts.title_proof.TitleProofAnchor.initialize[routing]() -> void:
initialize:
    // contracts/title_proof.py:44
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contracts/title_proof.py:58
    // assert Txn.sender == op.Global.creator_address, "Only creator can initialize"
    txn Sender
    global CreatorAddress
    ==
    assert // Only creator can initialize
    // contracts/title_proof.py:59
    // assert self.anchor_authority.get(default=Bytes(b"")) == Bytes(b""), "Already initialized"
    intc_0 // 0
    bytec_0 // "anchor_authority"
    app_global_get_ex
    bytec_2 // 0x
    cover 2
    select
    bytec_2 // 0x
    ==
    assert // Already initialized
    // contracts/title_proof.py:60
    // self.anchor_authority.value = authority.bytes
    bytec_0 // "anchor_authority"
    swap
    app_global_put
    // contracts/title_proof.py:44
    // @arc4.abimethod
    intc_1 // 1
    return


// contracts.title_proof.TitleProofAnchor.anchor_state[routing]() -> void:
anchor_state:
    // contracts/title_proof.py:62
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txna ApplicationArgs 5
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    txna ApplicationArgs 6
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // contracts/title_proof.py:98
    // assert Txn.sender.bytes == self.anchor_authority.value, "Unauthorized: only anchor authority can submit"
    txn Sender
    intc_0 // 0
    bytec_0 // "anchor_authority"
    app_global_get_ex
    assert // check self.anchor_authority exists
    ==
    assert // Unauthorized: only anchor authority can submit
    // contracts/title_proof.py:100-101
    // # Validate block range is coherent
    // assert fabric_block_end.native >= fabric_block_start.native, "Invalid block range: end < start"
    swap
    btoi
    uncover 2
    btoi
    >=
    assert // Invalid block range: end < start
    // contracts/title_proof.py:103-104
    // # Validate state root is non-empty
    // assert state_root.native.length > UInt64(0), "State root cannot be empty"
    extract 2 0
    len
    assert // State root cannot be empty
    // contracts/title_proof.py:106-107
    // # Increment the anchor counter
    // self.total_anchors.value = self.total_anchors.value + UInt64(1)
    intc_0 // 0
    bytec_1 // "total_anchors"
    app_global_get_ex
    assert // check self.total_anchors exists
    intc_1 // 1
    +
    bytec_1 // "total_anchors"
    swap
    app_global_put
    // contracts/title_proof.py:108
    // self.last_anchor_round.value = op.Global.round
    bytec_3 // "last_anchor_round"
    global Round
    app_global_put
    // contracts/title_proof.py:115
    // return arc4.UInt64(self.total_anchors.value)
    intc_0 // 0
    bytec_1 // "total_anchors"
    app_global_get_ex
    assert // check self.total_anchors exists
    itob
    // contracts/title_proof.py:62
    // @arc4.abimethod
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts.title_proof.TitleProofAnchor.get_anchor_count[routing]() -> void:
get_anchor_count:
    // contracts/title_proof.py:128
    // return arc4.UInt64(self.total_anchors.value)
    intc_0 // 0
    bytec_1 // "total_anchors"
    app_global_get_ex
    assert // check self.total_anchors exists
    itob
    // contracts/title_proof.py:117
    // @arc4.abimethod(readonly=True)
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts.title_proof.TitleProofAnchor.rotate_authority[routing]() -> void:
rotate_authority:
    // contracts/title_proof.py:130
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contracts/title_proof.py:146
    // assert Txn.sender.bytes == self.anchor_authority.value, "Unauthorized: only current authority can rotate"
    txn Sender
    intc_0 // 0
    bytec_0 // "anchor_authority"
    app_global_get_ex
    assert // check self.anchor_authority exists
    ==
    assert // Unauthorized: only current authority can rotate
    // contracts/title_proof.py:147
    // assert new_authority.bytes != Bytes(b""), "New authority cannot be empty"
    dup
    bytec_2 // 0x
    !=
    assert // New authority cannot be empty
    // contracts/title_proof.py:148
    // self.anchor_authority.value = new_authority.bytes
    bytec_0 // "anchor_authority"
    swap
    app_global_put
    // contracts/title_proof.py:130
    // @arc4.abimethod
    intc_1 // 1
    return
